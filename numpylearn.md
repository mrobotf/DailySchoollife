```
b = np.array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```
### 数组的维度、形状、大小
+ 查看数组的维度(矩阵的行数) `np.ndim`

    ```
    print('数组b的维度是：', b.ndim)
    数组b的维度是：2
    ```

+ `np.shape`：显示在每个维度里数组的大小，或者说数组的“形状”。如 n 行 m 列的矩阵，它的 shape 就是(n,m)。

    `数组b的形状是： (3, 3)`

+ `np.size`：数组中所有元素的总量，相当于数组的 `shape` 中所有元素的乘积。

    `b.size = m * n = 9`

### 数组的元素类型和存储大小
+ `np.dtype`：查看数组中元素的类型。创建数组时，可以指定dtype参数用于创建指定数据类型的数组

    ```
    d = np.array([1.2, 2.3, 3.4], dtype = np.float
    array([1.2, 2.3, 3.4])
    ```

+ `np.itemsize`：用于查看数组中元素占用的字节，例如，一个元素类型是float64的数组，其中的元素占用的字节大小是8（也就是64bit/8）

    `d.itemsize == 8`

+ `np.data`：查看存储数组的真实内存地址

    ```
    >>>d.data
    <memory at 0x10bf10ac8>
    ```

### 创建数组
有很多种方法创建数组。例如，你可以通过使用数组函数从一个python的列表或元组创建。数组元素的类型由原数据的类型推断得到。

+ np.array创建数组时，会将多层嵌套的列表转换为多维数组。
    ```
    >>>b = np.array([1.2, 3.5, 5.1])
    >>>b.dtype
    dtype('float64')

    # 多层嵌套列表
    >>>b = np.array([(1.5,2,3), (4,5,6)])
    >>>b
    array([[1.5, 2. , 3. ],
        [4. , 5. , 6. ]])
    ```

+ 创建数组时我们还可以指定数据类型

    ```
    >>>c = np.array( [ [1,2], [3,4] ], dtype=complex ) #指定数据类型为复数
    >>>c
    array([[1.+0.j, 2.+0.j],
           [3.+0.j, 4.+0.j]])
    ```

+ 若只知道数组大小，不知道数组元素。NumPy 提供多个函数用于创建有初始数值的占位数组。

    `zeros()`函数创建包含全是0的数组，`ones()`函数创建全是1的数组，`empty()`函数创建一个随机数值数组，其中的数值由当时的内存状态决定。这些函数创建的数组的数据类型都是默认的`float64`.

    ```
    >>>np.zeros( (3,4) )
    array([[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]])
    >>>np.ones( (2,3,4), dtype=np.int16 )
    array([[[1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1]],

        [[1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1]]], dtype=int16)
    >>>np.empty( (2,3) )
    array([[1.5, 2. , 3. ],
        [4. , 5. , 6. ]])
    ```

+ `range()` 函数生成连续的数值，返回数组而非列表

    ```
    >>>np.arange( 10, 30, 5 ) # 起始值10，终止值30，步进5
    array([10, 15, 20, 25])
    >>>np.arange( 0, 2, 0.3 )
    array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])
    ```

+ `arange()`使用浮点型作为参数时，浮点精度有限，不能预测创建的数组有多少个元素。在这种情况下，换成`linspace()`可更好确定区间内到底需要产生多少个数组元素。

    ```
    >>>np.linspace( 0, 2, 9 ) # 在[0,2]区间内生成9个值
    array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])
    ```
### 基本运算
数组中的算术运算一般是元素级的运算，运算结果会产生一个新的数组。

+ 乘法运算
    乘积运算操作`*`在 NumPy 中是元素级的运算。

    ```
    >>>A = np.array( [[1,1],[0,1]] )
    >>>B = np.array( [[2,0],[3,4]] )
    >>>A*B      # 元素乘积
    array([[2, 0],
        [0, 4]])
    >>>A.dot(B)     # 矩阵运算
    array([[5, 4],
        [3, 4]])
    >>>np.dot(A, B)     # 另一种方式矩阵运算
    array([[5, 4],
        [3, 4]])
    ```

+ 一些运算，例如`+=`和`*=`，会改变一个数组的值，而不是生成一个新的数组。

    ```
    >>>a = np.ones((2,3), dtype=int)
    >>>b = np.random.random((2,3))
    >>>a *= 3
    >>>a
    array([[3, 3, 3],
        [3, 3, 3]])
    >>>b += a
    >>>b
    array([[3.69902298, 3.1334804 , 3.62673199],
        [3.37038178, 3.74769131, 3.62235315]])
    >>>a += b # b不会自动转换为整型
    ```

+ 当操作不同数据类型的数组时，最后输出的数组类型一般会与更精准的数组相同（这种行为叫做 Upcasting）。
+ 许多一元运算，如计算数组中所有元素的总和，是属于 ndarray 类的方法。默认状态下，这些运算会把数组视为一个数字列表而不关心它的shape。

    ```
    >>>a = np.random.random((2,3))
    >>>a
    array([[0.85827711, 0.5385761 , 0.0843277 ],
        [0.2609027 , 0.36414539, 0.12940627]])
    >>>a.sum()
    2.2356352707158513
    >>>a.min()
    0.08432769616897462
    >>>a.max()
    0.8582771053112916
    ```
+ 指定axis参数针对哪一个维度进行运算。例如axis=0将针对每一个列进行运算。
    ```
    >>>b = np.arange(12).reshape(3,4)
    >>>b
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
    >>>b.sum(axis=0)# 列相加
    array([12, 15, 18, 21])
    >>>b.min(axis=1) #行相加
    array([0, 4, 8])
    >>>b.cumsum(axis=1)#行累加
    array([[ 0,  1,  3,  6],
        [ 4,  9, 15, 22],
        [ 8, 17, 27, 38]])
    ```

### 广播
用于不同大小数组的二元通用函数（加、减、乘等）的一组规则

广播的规则：
1. 如果两个数组的维度数dim不相同，那么小维度数组的形状将会在左边补1
2. 如果shape的维度不匹配，但是有维度是1，那么可以扩展维度是1的维度匹配另一个数组；
3. 如果shape的维度不匹配，但是没有任何一个维度是1，则匹配失败引发错误；

从上到下依次判断改变 shape

### 通用函数
NumPy提供一些熟悉的数学函数，例如sin, cos,和exp等。在NumPy中，这些函数称为“通用函数”， 这些运算是元素级的，生成一个数组作为结果。
    ```
    >>>B = np.arange(3)
    >>>B
    array([0, 1, 2])
    >>>np.exp(B)
    array([1.        , 2.71828183, 7.3890561 ])
    >>>np.sqrt(B)
    array([0.        , 1.        , 1.41421356])
    >>>C = np.array([2., -1., 4.])
    >>>np.add(B, C)
    array([2., 0., 6.])
    ```


### 索引、切片和迭代
一维数组可以索引、切片和迭代，就像列表和其他python数据类型。
    ```
    >>>a = np.arange(10)**3
    >>>a[2]
    8
    >>>a[2:5]
    array([ 8, 27, 64])
    >>>a[:6:2] = -1000 #从0到6，每隔2个设为-1000
    >>>a
    array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,
            729])
    >>>a[ : :-1] #翻转数组a
    array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1,
        -1000])
    ```
### 打印数组
Numpy 打印遵循：
1. 最后一维由左至右打印
2. 倒数第二维从上到下打印
3. 其余维都是从上到下打印，且通过空行分隔

    ```
    >>>a = np.arange(6)  
    >>>a
    array([0, 1, 2, 3, 4, 5])
    >>>b = np.arange(12).reshape(4,3)
    >>>b
    array([[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8],
        [ 9, 10, 11]])
    >>>c = np.arange(24).reshape(2,3,4)
    >>>c
    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],

        [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]]])
    ```
+ 如果数组太大了，NumPy自动跳过中间的部分不显示，只显示两边(上下和左右的两边)。

### 改变数组的形状
+ 以下的三个命令都能返回一个被改变的数组，但是并不改变原数组。`reshape`函数返回的是改变了形状数组，而`resize`方法改变的是数组本身的形状。

    ```
    >>> a.ravel()  # 返回被平坦化的数组
    array([7., 1., 0., 7., 7., 3., 3., 4., 3., 9., 2., 9.])
    >>> a.reshape(6,2)  # 返回一个改变形状的数组
    array([[7., 1.],
        [0., 7.],
        [7., 3.],
        [3., 4.],
        [3., 9.],
        [2., 9.]])
    >>> a.T  # 返回一个被转置的数组
    array([[7., 7., 3.],
        [1., 3., 9.],
        [0., 3., 2.],
        [7., 4., 9.]])
    >>> a.T.shape
    (4, 3)
    >>> a.shape # 原数组的形状不变
    (3, 4)

    >>> a
    array([[7., 1., 0., 7.],
        [7., 3., 3., 4.],
        [3., 9., 2., 9.]])
    >>> a.resize((2,6))
    >>> a # resize 之后，a的形状变了，这是与reshape的区别
    array([[7., 1., 0., 7., 7., 3.],
        [3., 4., 3., 9., 2., 9.]])
    ```